export interface BlockType {
  name: string;
  description: string;
}

export interface BuildingBlock {
  id: string;
  name: string;
  emoji: string;
  category: string;
  description: string;
  howItWorks: string;
  types: BlockType[];
  whenToUse: string[];
  keyMetrics: string[];
  realWorldTools: string[];
  interviewTips: string[];
}

export const buildingBlocks: BuildingBlock[] = [
  {
    id: 'load-balancer',
    name: 'Load Balancers',
    emoji: 'âš–ï¸',
    category: 'Networking',
    description: 'Distributes incoming network traffic across multiple servers to ensure no single server is overwhelmed, improving availability and throughput.',
    howItWorks: 'A load balancer sits between clients and servers. It receives requests and forwards them to one of several backend servers using a configured algorithm. It monitors server health and removes unhealthy servers from the pool. Load balancers can operate at Layer 4 (TCP/UDP â€” fast, based on IP/port) or Layer 7 (HTTP â€” smart, can inspect headers, cookies, URL paths).',
    types: [
      { name: 'L4 (Transport Layer)', description: 'Routes based on IP address and port. Very fast, no packet inspection. Used for raw TCP/UDP traffic. Example: AWS NLB.' },
      { name: 'L7 (Application Layer)', description: 'Routes based on HTTP headers, URL path, cookies. Can do content-based routing, SSL termination. Example: AWS ALB, Nginx.' },
      { name: 'DNS Load Balancing', description: 'Returns different IP addresses for the same domain. Simple but lacks health checks and has TTL caching issues.' },
      { name: 'Global Server Load Balancing (GSLB)', description: 'Routes users to the nearest data center based on geography. Example: Cloudflare, AWS Route 53.' },
    ],
    whenToUse: [
      'Any system serving more than one server',
      'Need high availability â€” LB detects and routes around failures',
      'Horizontal scaling â€” distribute load across many instances',
      'SSL termination â€” offload encryption to LB',
    ],
    keyMetrics: [
      'Requests per second (RPS)',
      'Latency (p50, p95, p99)',
      'Active connections',
      'Backend health check pass rate',
      'Error rate (5xx responses)',
    ],
    realWorldTools: [
      'Nginx / Nginx Plus',
      'HAProxy',
      'AWS ALB (Application Load Balancer) â€” L7',
      'AWS NLB (Network Load Balancer) â€” L4',
      'Envoy Proxy',
      'Cloudflare Load Balancing',
      'Google Cloud Load Balancing',
    ],
    interviewTips: [
      'Always mention which layer (L4 vs L7) and why',
      'Common algorithms: Round Robin, Least Connections, IP Hash (sticky sessions), Weighted Round Robin',
      'Mention health checks â€” LBs detect unhealthy servers and stop routing to them',
      'For global apps, mention GSLB + regional LBs (two-tier architecture)',
      'SSL termination at LB reduces backend CPU load',
      'Sticky sessions (IP hash or cookie) when session state is on the server â€” but mention this is an anti-pattern (prefer stateless)',
    ],
  },
  {
    id: 'cache',
    name: 'Caches',
    emoji: 'âš¡',
    category: 'Performance',
    description: 'In-memory data store that serves frequently accessed data faster than the primary database. Reduces read latency from milliseconds to microseconds.',
    howItWorks: 'Cache stores a subset of data in fast memory (RAM). On a read request, the application first checks the cache (cache hit). If not found (cache miss), it reads from the database, stores the result in cache, and returns it. Cache eviction policies (LRU, LFU, TTL) manage the limited memory space.',
    types: [
      { name: 'Write-Through', description: 'Data is written to cache AND database synchronously. Ensures cache is always consistent. Higher write latency but strong consistency.' },
      { name: 'Write-Back (Write-Behind)', description: 'Data is written to cache first, then asynchronously to database. Very fast writes but risk of data loss if cache crashes before persisting.' },
      { name: 'Write-Around', description: 'Data is written directly to database, bypassing cache. Cache is populated only on reads (cache-aside). Avoids cache pollution from writes.' },
      { name: 'Cache-Aside (Lazy Loading)', description: 'Application manages cache: check cache â†’ if miss, read DB â†’ populate cache. Most flexible pattern. Application controls what gets cached.' },
      { name: 'Read-Through', description: 'Cache sits between app and DB. On miss, cache itself fetches from DB. App only talks to cache.' },
      { name: 'CDN Cache', description: 'Content Delivery Network caches static assets at edge locations globally. Reduces latency for geographically distributed users.' },
    ],
    whenToUse: [
      'Read-heavy workloads (high read:write ratio)',
      'Data that is expensive to compute or fetch',
      'Frequently accessed data (hot data)',
      'Data that can tolerate slight staleness',
      'Reducing database load and costs',
    ],
    keyMetrics: [
      'Cache hit ratio (target > 90%)',
      'Cache miss ratio',
      'Latency: cache hit (~0.1ms) vs DB read (~5-10ms)',
      'Eviction rate',
      'Memory usage',
      'TTL (Time to Live) values',
    ],
    realWorldTools: [
      'Redis â€” most popular, supports data structures, pub/sub, persistence',
      'Memcached â€” simple key-value, multi-threaded, no persistence',
      'Cloudflare / CloudFront CDN â€” edge caching',
      'Varnish â€” HTTP reverse proxy cache',
      'Application-level cache (Guava, Caffeine for Java)',
    ],
    interviewTips: [
      'Always discuss cache invalidation â€” "the two hardest problems in CS: cache invalidation, naming things, and off-by-one errors"',
      'Mention TTL as the simplest invalidation strategy',
      'Cache stampede / thundering herd: many requests hit DB simultaneously on cache miss â€” mitigate with locking or request coalescing',
      'Redis vs Memcached: Redis has data structures + persistence + replication; Memcached is simpler, multi-threaded, slightly faster for simple key-value',
      'Hot key problem: one key gets disproportionate traffic â€” replicate across shards or use local cache',
      'Mention cache-aside as the default go-to pattern for most systems',
    ],
  },
  {
    id: 'database',
    name: 'Databases',
    emoji: 'ðŸ—„ï¸',
    category: 'Storage',
    description: 'Persistent data storage systems. The choice between SQL and NoSQL, and the strategies for scaling (sharding, replication, partitioning) are fundamental to system design.',
    howItWorks: 'SQL databases store data in structured tables with predefined schemas, supporting ACID transactions and complex joins. NoSQL databases trade some of these guarantees for flexibility and horizontal scalability. Scaling strategies include: vertical scaling (bigger machine), read replicas (scale reads), sharding (scale writes by partitioning data), and partitioning (splitting tables).',
    types: [
      { name: 'Relational (SQL)', description: 'Structured data, ACID transactions, complex queries with JOINs. Best for structured, relational data. Examples: PostgreSQL, MySQL, Aurora.' },
      { name: 'Document Store', description: 'Flexible JSON-like documents, schema-less. Good for variable schemas. Examples: MongoDB, CouchDB, DynamoDB.' },
      { name: 'Key-Value Store', description: 'Simplest model â€” get/set by key. Extremely fast, highly scalable. Examples: Redis, DynamoDB, Riak.' },
      { name: 'Wide-Column Store', description: 'Column families for large-scale analytics and time-series. Examples: Cassandra, HBase, Google Bigtable.' },
      { name: 'Graph Database', description: 'Optimized for relationships and traversals. Examples: Neo4j, Amazon Neptune. Use for social networks, fraud detection.' },
      { name: 'Time-Series Database', description: 'Optimized for time-stamped data. Examples: InfluxDB, TimescaleDB. Use for metrics, IoT, monitoring.' },
    ],
    whenToUse: [
      'SQL: When you need ACID, complex queries, JOINs, structured data',
      'NoSQL: When you need flexible schema, horizontal scaling, high write throughput',
      'Document: Variable structure data, rapid prototyping',
      'Key-Value: Caching, session storage, simple lookups',
      'Wide-Column: Time-series, write-heavy analytics',
      'Graph: Social networks, recommendation engines, fraud detection',
    ],
    keyMetrics: [
      'QPS (Queries Per Second)',
      'Read/Write latency (p50, p95, p99)',
      'Storage capacity and growth rate',
      'Replication lag',
      'Connection pool utilization',
      'IOPS (I/O Operations Per Second)',
    ],
    realWorldTools: [
      'PostgreSQL â€” most versatile SQL DB, supports JSON too',
      'MySQL / Aurora â€” AWS managed, popular for web apps',
      'MongoDB â€” leading document store',
      'Cassandra â€” write-heavy, highly available, eventual consistency',
      'DynamoDB â€” AWS managed key-value/document, auto-scaling',
      'Redis â€” in-memory, used as cache and data store',
      'Neo4j â€” graph database leader',
    ],
    interviewTips: [
      'Default to SQL unless you have a specific reason for NoSQL',
      'Sharding strategies: hash-based (even distribution) vs range-based (range queries). Mention consistent hashing.',
      'Replication: leader-follower for read scaling. Leader handles writes, followers serve reads.',
      'Know when to denormalize: join-heavy queries at scale â†’ pre-join and denormalize',
      'Mention CAP theorem: SQL typically CP (consistent + partition tolerant), NoSQL often AP (available + partition tolerant)',
      'Connection pooling is critical at scale â€” mention PgBouncer for PostgreSQL',
    ],
  },
  {
    id: 'message-queue',
    name: 'Message Queues',
    emoji: 'ðŸ“¬',
    category: 'Communication',
    description: 'Asynchronous communication mechanism where producers send messages to a queue and consumers process them independently, decoupling system components.',
    howItWorks: 'A producer publishes a message to a queue or topic. The message broker stores it durably. One or more consumers pull (or are pushed) messages and process them. Messages are acknowledged after successful processing. Failed messages can be retried or sent to a Dead Letter Queue (DLQ). This decouples producers and consumers in time and space.',
    types: [
      { name: 'Point-to-Point Queue', description: 'Each message consumed by exactly one consumer. Used for task distribution. Example: SQS, RabbitMQ queue.' },
      { name: 'Publish-Subscribe (Pub/Sub)', description: 'Messages broadcast to all subscribers. Used for event notification. Example: SNS, Kafka topics, RabbitMQ exchanges.' },
      { name: 'Log-Based Queue', description: 'Append-only log where consumers track their position (offset). Supports replay. Example: Kafka, Kinesis, Pulsar.' },
      { name: 'Priority Queue', description: 'Messages have priority levels. Higher priority messages processed first. Example: RabbitMQ priority queues.' },
    ],
    whenToUse: [
      'Asynchronous processing â€” don\'t block the user for slow operations',
      'Decoupling services â€” producer and consumer can scale independently',
      'Buffering â€” handle traffic spikes by queuing messages',
      'Guaranteed delivery â€” messages persist even if consumer is temporarily down',
      'Event-driven architecture â€” propagate events across services',
    ],
    keyMetrics: [
      'Throughput (messages/second)',
      'Latency (enqueue to dequeue time)',
      'Queue depth (backlog)',
      'Consumer lag (behind latest message)',
      'DLQ message count (failed messages)',
      'Message retention period',
    ],
    realWorldTools: [
      'Apache Kafka â€” distributed log, high throughput (millions msg/sec), ordering within partition',
      'RabbitMQ â€” traditional message broker, flexible routing, AMQP protocol',
      'Amazon SQS â€” fully managed, simple queue, at-least-once delivery',
      'Amazon SNS â€” pub/sub service, integrates with SQS, Lambda',
      'Apache Pulsar â€” multi-tenant, geo-replication, tiered storage',
      'Google Pub/Sub â€” managed, global, at-least-once delivery',
    ],
    interviewTips: [
      'Kafka vs RabbitMQ: Kafka = log-based, high throughput, replay, ordering per partition. RabbitMQ = traditional broker, flexible routing, lower latency per message.',
      'Always mention Dead Letter Queue (DLQ) for handling failed messages',
      'Idempotent consumers are essential with at-least-once delivery',
      'Kafka ordering: guaranteed within a partition only. Use partition key (e.g., user_id) to ensure ordering per entity.',
      'Backpressure: consumers process at their own rate â€” queue absorbs spikes',
      'Message retention: Kafka retains messages (configurable days/size); SQS deletes after consumption',
    ],
  },
  {
    id: 'cdn',
    name: 'CDN (Content Delivery Network)',
    emoji: 'ðŸŒ',
    category: 'Networking',
    description: 'Geographically distributed network of edge servers that cache content close to users, reducing latency and offloading origin servers.',
    howItWorks: 'When a user requests content, DNS routes them to the nearest CDN edge server (Point of Presence / PoP). If the edge has cached content (cache hit), it serves directly with very low latency. On a cache miss, the edge fetches from the origin server, caches it, and serves the user. TTL controls how long content stays cached.',
    types: [
      { name: 'Push CDN', description: 'Content is uploaded/pushed to CDN proactively. You control exactly what\'s cached. Good for content that changes infrequently (assets, videos). Higher initial upload effort.' },
      { name: 'Pull CDN', description: 'CDN pulls content from origin on first request and caches it. Simpler setup, content cached on demand. Good for dynamic sites. May have first-request latency.' },
    ],
    whenToUse: [
      'Serving static assets (images, CSS, JS, videos) to global users',
      'Reducing latency for geographically distributed user base',
      'Offloading traffic from origin servers',
      'DDoS protection â€” CDN absorbs traffic at the edge',
      'Video streaming â€” edge caching reduces bandwidth costs',
    ],
    keyMetrics: [
      'Cache hit ratio (target > 95% for static assets)',
      'Time to First Byte (TTFB)',
      'Edge latency (ms)',
      'Bandwidth savings vs origin',
      'Origin offload percentage',
    ],
    realWorldTools: [
      'Cloudflare â€” CDN + security + DDoS protection',
      'AWS CloudFront â€” integrated with S3 and AWS services',
      'Akamai â€” enterprise CDN, largest network',
      'Fastly â€” edge computing + CDN, real-time purging',
      'Google Cloud CDN',
    ],
    interviewTips: [
      'Mention push vs pull and when to use each',
      'Cache invalidation: purge vs TTL-based expiry. Versioned URLs (app.v2.js) avoid invalidation issues.',
      'CDN for API responses: cache GET requests with appropriate Cache-Control headers',
      'Edge computing: modern CDNs (Cloudflare Workers, Fastly Compute) can run code at the edge',
      'Multi-CDN: large companies use multiple CDNs for redundancy (Netflix uses their own Open Connect)',
    ],
  },
  {
    id: 'dns',
    name: 'DNS & Domain Resolution',
    emoji: 'ðŸ“–',
    category: 'Networking',
    description: 'Domain Name System translates human-readable domain names to IP addresses. It\'s the internet\'s phone book and the first step in every web request.',
    howItWorks: 'Browser checks local cache â†’ OS cache â†’ Router cache â†’ ISP recursive resolver â†’ Root nameserver â†’ TLD nameserver (.com) â†’ Authoritative nameserver â†’ Returns IP address. Each step may be cached with TTL. Modern DNS also supports load balancing (multiple A records), geographic routing (GeoDNS), and health checks.',
    types: [
      { name: 'A Record', description: 'Maps domain to IPv4 address. The most basic record type.' },
      { name: 'AAAA Record', description: 'Maps domain to IPv6 address.' },
      { name: 'CNAME Record', description: 'Alias â€” points domain to another domain. e.g., www.example.com â†’ example.com' },
      { name: 'MX Record', description: 'Mail exchange â€” specifies mail servers for a domain.' },
      { name: 'NS Record', description: 'Nameserver â€” delegates DNS zone to an authoritative server.' },
      { name: 'SRV Record', description: 'Service discovery â€” specifies host/port for specific services.' },
    ],
    whenToUse: [
      'Every internet-facing system uses DNS',
      'Geographic load balancing â€” route users to nearest data center',
      'Service discovery in some architectures',
      'Failover â€” health-checked DNS records route around outages',
    ],
    keyMetrics: [
      'DNS resolution time (typically 20-120ms)',
      'TTL values (balance between freshness and cache hits)',
      'DNS propagation time for changes',
    ],
    realWorldTools: [
      'AWS Route 53 â€” managed DNS with health checks, GeoDNS',
      'Cloudflare DNS â€” fast, free tier',
      'Google Cloud DNS',
      'BIND â€” open-source DNS server',
    ],
    interviewTips: [
      'Mention DNS as the first step in any system design: "The user types the URL, DNS resolves it to the load balancer IP..."',
      'Low TTL for failover scenarios (30-60 seconds); high TTL for stable services (hours/days)',
      'DNS is the simplest form of load balancing but has limitations (caching, no health awareness without managed DNS)',
      'GeoDNS for multi-region: Route 53 geolocation/latency-based routing',
    ],
  },
  {
    id: 'proxy',
    name: 'Proxies',
    emoji: 'ðŸ”€',
    category: 'Networking',
    description: 'An intermediary server that sits between clients and backend servers, handling requests on behalf of one side.',
    howItWorks: 'A forward proxy acts on behalf of clients (hiding client identity, caching, filtering). A reverse proxy acts on behalf of servers (load balancing, SSL termination, caching, compression). In system design, reverse proxies are far more common.',
    types: [
      { name: 'Forward Proxy', description: 'Client-side proxy. Client sends requests to proxy, which forwards to the internet. Used for: access control, caching, anonymity (VPN/Tor). Example: corporate firewall proxies.' },
      { name: 'Reverse Proxy', description: 'Server-side proxy. Clients think they\'re talking to the proxy, which forwards to backend servers. Used for: load balancing, SSL termination, caching, security. Example: Nginx, HAProxy.' },
    ],
    whenToUse: [
      'Reverse proxy: always in production web architectures (Nginx, HAProxy)',
      'SSL termination at the proxy layer',
      'Request routing and load balancing',
      'Caching and compression',
      'Security â€” hide backend server details from clients',
    ],
    keyMetrics: [
      'Request throughput (RPS)',
      'Proxy latency overhead',
      'Connection count',
      'Cache hit ratio (if caching enabled)',
    ],
    realWorldTools: [
      'Nginx â€” most popular reverse proxy and web server',
      'HAProxy â€” high-performance TCP/HTTP proxy',
      'Envoy â€” modern L7 proxy, service mesh',
      'Traefik â€” cloud-native reverse proxy',
      'Apache HTTP Server â€” with mod_proxy',
    ],
    interviewTips: [
      'In system design, "proxy" almost always means reverse proxy',
      'Nginx is the default answer for reverse proxy in most designs',
      'Reverse proxy vs load balancer: a reverse proxy CAN load balance, but also does caching, SSL termination, compression. LB is more focused.',
      'Mention reverse proxy as the first layer after DNS in your architecture',
    ],
  },
  {
    id: 'consistent-hashing',
    name: 'Consistent Hashing',
    emoji: 'ðŸŽ¯',
    category: 'Distributed Systems',
    description: 'A hashing technique where adding or removing a server only remaps a minimal fraction of keys, unlike traditional hashing which remaps most keys.',
    howItWorks: 'Servers and keys are mapped onto a circular hash ring (0 to 2^32). Each key is assigned to the next server clockwise on the ring. When a server is added/removed, only keys between the affected server and its predecessor need to remap â€” typically only K/N keys (K=total keys, N=servers). Virtual nodes improve distribution: each physical server gets multiple positions on the ring.',
    types: [
      { name: 'Basic Consistent Hashing', description: 'Each server gets one position on the ring. Simple but can lead to uneven distribution.' },
      { name: 'Virtual Nodes (VNodes)', description: 'Each physical server mapped to multiple positions on the ring. Ensures more even distribution and smoother rebalancing. Standard approach.' },
    ],
    whenToUse: [
      'Distributed caches (Memcached, Redis cluster) â€” minimize cache misses on scale events',
      'Database sharding â€” consistent data distribution across shards',
      'Content distribution â€” map content to servers',
      'Any distributed system where nodes join/leave frequently',
    ],
    keyMetrics: [
      'Key distribution evenness across nodes',
      'Percentage of keys remapped on node add/remove (should be ~1/N)',
      'Number of virtual nodes per physical node (typically 100-200)',
    ],
    realWorldTools: [
      'Cassandra â€” uses consistent hashing for data partitioning',
      'DynamoDB â€” uses consistent hashing internally',
      'Memcached client libraries (ketama algorithm)',
      'Redis Cluster',
      'Akka Cluster â€” consistent hashing router',
    ],
    interviewTips: [
      'Draw the ring! Interviewers love seeing the hash ring diagram',
      'Always mention virtual nodes â€” basic consistent hashing has uneven distribution',
      'Compare with simple modulo hashing: modulo(hash, N) remaps almost all keys when N changes; consistent hashing remaps only K/N',
      'This is the answer to "how do you distribute data across cache servers?" in almost every interview',
      'Mention it when discussing sharding strategy for databases',
    ],
  },
  {
    id: 'rate-limiter',
    name: 'Rate Limiting',
    emoji: 'ðŸš¦',
    category: 'Security & Reliability',
    description: 'Controls the rate of incoming requests to protect services from being overwhelmed, prevent abuse, and ensure fair usage.',
    howItWorks: 'A rate limiter sits in front of your service (often at the API gateway or load balancer). It tracks request counts per client (by IP, API key, or user ID) within a time window. Requests exceeding the limit receive HTTP 429 (Too Many Requests). Limits can be set per endpoint, per user, or globally.',
    types: [
      { name: 'Token Bucket', description: 'Bucket holds tokens (capacity B). Tokens added at fixed rate (R/sec). Each request consumes a token. Allows bursts up to B. Most popular algorithm. Used by AWS, Stripe.' },
      { name: 'Leaky Bucket', description: 'Requests enter a queue (bucket). Processed at fixed rate. Excess requests overflow (dropped). Smooths traffic to constant rate. Used by Nginx.' },
      { name: 'Fixed Window Counter', description: 'Count requests in fixed time windows (e.g., per minute). Simple but has boundary burst problem (2x burst at window edge).' },
      { name: 'Sliding Window Log', description: 'Track timestamp of each request. Count requests in rolling window. Accurate but memory-intensive.' },
      { name: 'Sliding Window Counter', description: 'Hybrid of fixed window + sliding. Weighted count from current + previous window. Good balance of accuracy and efficiency.' },
    ],
    whenToUse: [
      'Protecting APIs from abuse and DDoS',
      'Enforcing usage tiers (free: 100 req/min, premium: 10K req/min)',
      'Preventing resource exhaustion from buggy clients',
      'Ensuring fair usage across users',
    ],
    keyMetrics: [
      'Requests allowed vs throttled',
      'Throttle rate (429 responses / total)',
      'Per-client request rates',
      'Latency impact of rate limiting logic',
    ],
    realWorldTools: [
      'Redis â€” most common backend for distributed rate limiting (INCR + EXPIRE)',
      'Nginx â€” built-in rate limiting module',
      'AWS API Gateway â€” built-in throttling',
      'Kong â€” rate limiting plugin',
      'Cloudflare â€” edge rate limiting',
    ],
    interviewTips: [
      'Token bucket is the default answer â€” it handles bursts gracefully and is used by AWS/Stripe',
      'Distributed rate limiting: use Redis with atomic INCR + EXPIRE for centralized counting',
      'Race conditions: use Redis Lua scripts for atomic check-and-increment',
      'Return Retry-After header with 429 responses to help clients back off',
      'Rate limit by: IP (simple, NAT issues), API key (better), user ID (best)',
      'This is a classic interview question on its own â€” "Design a Rate Limiter"',
    ],
  },
  {
    id: 'blob-storage',
    name: 'Blob Storage',
    emoji: 'ðŸ“¦',
    category: 'Storage',
    description: 'Object storage for unstructured data (images, videos, documents, backups). Optimized for large files with high durability and availability.',
    howItWorks: 'Objects are stored with a unique key in a flat namespace (bucket/key). Each object contains data + metadata. Objects are immutable â€” you replace, not update. Storage is replicated across multiple availability zones for durability (11 9s = 99.999999999%). Access via HTTP APIs (PUT/GET). Supports lifecycle policies for archiving/deletion.',
    types: [
      { name: 'Standard (Hot) Storage', description: 'Frequent access. Low latency. Higher cost per GB. Example: S3 Standard.' },
      { name: 'Infrequent Access', description: 'Lower storage cost, higher retrieval cost. For data accessed < once/month. Example: S3 IA.' },
      { name: 'Archive Storage', description: 'Very low storage cost, high retrieval time (hours). For compliance, backups. Example: S3 Glacier.' },
    ],
    whenToUse: [
      'Storing images, videos, audio, documents',
      'Static website hosting',
      'Data lake storage',
      'Backups and disaster recovery',
      'Serving user-generated content via CDN',
    ],
    keyMetrics: [
      'Durability (S3: 99.999999999% â€” 11 nines)',
      'Availability (S3 Standard: 99.99%)',
      'Request latency (first byte)',
      'Storage cost per GB per month',
      'Data transfer costs',
    ],
    realWorldTools: [
      'AWS S3 â€” the standard, most widely used',
      'Google Cloud Storage',
      'Azure Blob Storage',
      'MinIO â€” S3-compatible open-source',
      'Cloudflare R2 â€” S3-compatible, no egress fees',
    ],
    interviewTips: [
      'S3 is the default answer for "where to store images/videos/files"',
      'Never store large files in a database â€” use blob storage + store the URL in DB',
      'Pre-signed URLs: give clients temporary direct upload/download access to S3 without going through your server',
      'Combine with CDN: S3 as origin â†’ CloudFront as CDN for fast delivery',
      'Lifecycle policies: automatically move old data from hot â†’ warm â†’ cold â†’ archive',
    ],
  },
  {
    id: 'search',
    name: 'Search (Full-Text)',
    emoji: 'ðŸ”',
    category: 'Data',
    description: 'Specialized search engines that index text data and provide fast full-text search, fuzzy matching, faceted search, and relevance ranking.',
    howItWorks: 'Data is ingested and broken into tokens (tokenization). An inverted index maps each token to the documents containing it (like a book index). At query time, the search engine looks up tokens in the inverted index, scores documents by relevance (TF-IDF, BM25), and returns ranked results. Supports fuzzy matching, autocomplete, and aggregations.',
    types: [
      { name: 'Inverted Index', description: 'Core data structure. Maps terms â†’ documents. Enables fast full-text lookup. Used by Elasticsearch, Solr.' },
      { name: 'Vector Search', description: 'Maps documents and queries to embedding vectors. Finds semantically similar content (not just keyword match). Used in AI/ML applications.' },
    ],
    whenToUse: [
      'Full-text search across large document collections',
      'Autocomplete / typeahead features',
      'Log analysis and monitoring (ELK stack)',
      'E-commerce product search with facets and filters',
      'When database LIKE queries are too slow',
    ],
    keyMetrics: [
      'Query latency (p50, p99)',
      'Indexing throughput (documents/second)',
      'Index size vs raw data size',
      'Relevance quality (precision, recall)',
    ],
    realWorldTools: [
      'Elasticsearch â€” most popular, distributed, REST API, part of ELK stack',
      'Apache Solr â€” mature, built on Lucene',
      'OpenSearch â€” AWS fork of Elasticsearch',
      'Typesense â€” lightweight, easy to use',
      'Meilisearch â€” developer-friendly, fast setup',
      'Algolia â€” hosted search-as-a-service',
    ],
    interviewTips: [
      'Elasticsearch is the default answer for search in system design',
      'Don\'t use your primary DB for search â€” use a dedicated search index synced via events or CDC',
      'Mention inverted index as the key data structure',
      'Data sync: DB â†’ Change Data Capture (CDC) or event stream â†’ Elasticsearch',
      'For autocomplete: use prefix queries or edge n-gram tokenizer',
      'Elasticsearch is also great for analytics and log aggregation (ELK: Elasticsearch + Logstash + Kibana)',
    ],
  },
  {
    id: 'monitoring',
    name: 'Monitoring & Logging',
    emoji: 'ðŸ“Š',
    category: 'Observability',
    description: 'Systems for collecting, aggregating, and analyzing metrics, logs, and traces to understand system health, debug issues, and set up alerts.',
    howItWorks: 'The three pillars of observability: Metrics (numeric time-series data â€” CPU, latency, error rates), Logs (timestamped text records of events), and Traces (end-to-end request path across services). Data is collected via agents/SDKs, sent to aggregation systems, stored in time-series databases, and visualized in dashboards. Alerts trigger on anomalies or threshold breaches.',
    types: [
      { name: 'Metrics', description: 'Numeric measurements over time. Counters, gauges, histograms. Example: request rate, error rate, p99 latency. Tools: Prometheus, Datadog, CloudWatch.' },
      { name: 'Logs', description: 'Timestamped text records. Structured (JSON) or unstructured. Example: request logs, error logs, audit logs. Tools: ELK stack, Splunk, Loki.' },
      { name: 'Traces', description: 'End-to-end request journey across services. Shows where time is spent. Example: Jaeger, Zipkin, AWS X-Ray, OpenTelemetry.' },
      { name: 'Alerting', description: 'Automated notifications when metrics breach thresholds. PagerDuty, OpsGenie, Prometheus Alertmanager.' },
    ],
    whenToUse: [
      'Every production system needs monitoring â€” it\'s not optional',
      'Metrics for dashboards and alerting',
      'Logs for debugging specific issues',
      'Traces for understanding distributed system behavior',
    ],
    keyMetrics: [
      'The "Four Golden Signals" (Google SRE): Latency, Traffic, Errors, Saturation',
      'SLI/SLO/SLA: Service Level Indicators, Objectives, Agreements',
      'p50, p95, p99, p999 latencies',
      'Error rate (5xx / total requests)',
      'Uptime percentage',
    ],
    realWorldTools: [
      'Prometheus + Grafana â€” open-source metrics + visualization',
      'Datadog â€” all-in-one SaaS monitoring',
      'ELK Stack (Elasticsearch + Logstash + Kibana) â€” log aggregation',
      'Jaeger / Zipkin â€” distributed tracing',
      'OpenTelemetry â€” vendor-neutral observability framework',
      'PagerDuty / OpsGenie â€” alerting and on-call management',
      'AWS CloudWatch â€” native AWS monitoring',
    ],
    interviewTips: [
      'Mention monitoring as a component in EVERY system design â€” it shows operational maturity',
      'Use the "Four Golden Signals" from Google SRE when discussing what to monitor',
      'Mention OpenTelemetry as the emerging standard for instrumentation',
      'Log aggregation is essential for microservices â€” you can\'t SSH into each container to read logs',
      'Distributed tracing is critical for debugging cross-service latency issues',
      'Health check endpoints (/health, /ready) for load balancer and Kubernetes probes',
    ],
  },
];
