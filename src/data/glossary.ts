// System Design Glossary — 100+ Terms

export interface GlossaryTerm {
  term: string;
  definition: string;
  category: string;
}

export const glossaryTerms: GlossaryTerm[] = [
  // === DISTRIBUTED SYSTEMS ===
  { term: "CAP Theorem", definition: "States that a distributed system can guarantee at most 2 of 3 properties: Consistency, Availability, and Partition Tolerance. During a network partition, you must choose between C and A.", category: "distributed-systems" },
  { term: "PACELC Theorem", definition: "Extension of CAP: if Partition, choose Availability or Consistency; Else (no partition), choose Latency or Consistency. Captures the latency-consistency tradeoff during normal operation.", category: "distributed-systems" },
  { term: "Consensus", definition: "The process of getting all nodes in a distributed system to agree on a single value. Algorithms include Paxos, Raft, and Zab.", category: "distributed-systems" },
  { term: "Paxos", definition: "A family of protocols for achieving consensus in unreliable networks. Complex to implement but theoretically foundational. Proposers, acceptors, and learners.", category: "distributed-systems" },
  { term: "Raft", definition: "A consensus algorithm designed to be more understandable than Paxos. Uses leader election and log replication. Used by etcd, CockroachDB.", category: "distributed-systems" },
  { term: "Vector Clock", definition: "A mechanism for tracking causality in distributed systems. Each node maintains a vector of counters. Allows detection of concurrent (conflicting) events.", category: "distributed-systems" },
  { term: "Lamport Timestamp", definition: "A logical clock that provides a partial ordering of events in a distributed system. Simple counter incremented on each event and message.", category: "distributed-systems" },
  { term: "Split-Brain", definition: "A failure mode where network partition causes two groups of nodes to operate independently, both believing they are authoritative. Requires fencing to resolve.", category: "distributed-systems" },
  { term: "Quorum", definition: "The minimum number of nodes that must participate in a read/write for it to be valid. Typically majority (N/2+1). If W+R>N, strong consistency is achieved.", category: "distributed-systems" },
  { term: "Gossip Protocol", definition: "A peer-to-peer communication protocol where nodes randomly share state information with neighbors. Eventually all nodes converge. Used for failure detection and membership.", category: "distributed-systems" },
  { term: "Heartbeat", definition: "Periodic signal sent between nodes to indicate liveness. If heartbeats stop, the node is suspected of failure. Basis for failure detection.", category: "distributed-systems" },
  { term: "Fencing Token", definition: "A monotonically increasing token issued with each lock grant. Prevents stale lock holders from making writes after a new lock holder has been granted access.", category: "distributed-systems" },
  { term: "Two-Phase Commit (2PC)", definition: "A distributed transaction protocol: Phase 1 (prepare) — coordinator asks all participants to vote; Phase 2 (commit/abort) — if all vote yes, commit; otherwise abort. Blocking protocol.", category: "distributed-systems" },
  { term: "Saga Pattern", definition: "A sequence of local transactions where each step has a compensating transaction for rollback. Alternative to 2PC for long-lived distributed transactions.", category: "distributed-systems" },
  { term: "Idempotency", definition: "Property where performing an operation multiple times produces the same result as performing it once. Critical for safe retries in distributed systems.", category: "distributed-systems" },
  { term: "Exactly-Once Semantics", definition: "Guarantee that a message/operation is processed exactly once. Hard to achieve; usually approximated with at-least-once delivery + idempotent processing.", category: "distributed-systems" },
  { term: "Crdt (Conflict-Free Replicated Data Type)", definition: "Data structures that can be replicated across nodes and merged without coordination. Guarantees eventual consistency. Types: counters, sets, registers.", category: "distributed-systems" },
  { term: "Crdt (Conflict-Free Replicated Data Type)", definition: "Data structures that can be replicated across nodes and merged without coordination, guaranteeing eventual consistency without conflicts.", category: "distributed-systems" },

  // === DATABASES ===
  { term: "ACID", definition: "Atomicity (all or nothing), Consistency (valid state transitions), Isolation (concurrent txns don't interfere), Durability (committed data persists). Guarantees for relational databases.", category: "databases" },
  { term: "BASE", definition: "Basically Available, Soft state, Eventually consistent. The NoSQL counterpart to ACID. Trades strong consistency for availability and performance.", category: "databases" },
  { term: "Sharding", definition: "Horizontal partitioning of data across multiple database instances. Each shard holds a subset of data. Enables horizontal scaling but complicates cross-shard queries.", category: "databases" },
  { term: "Replication", definition: "Copying data across multiple nodes for durability and read scaling. Types: leader-follower, leader-leader, leaderless. Tradeoffs in consistency and latency.", category: "databases" },
  { term: "Leader-Follower Replication", definition: "One node (leader) accepts writes and replicates to followers. Followers serve reads. Simple but leader is a bottleneck and SPOF without failover.", category: "databases" },
  { term: "Multi-Leader Replication", definition: "Multiple nodes accept writes and replicate to each other. Better write availability but requires conflict resolution. Used in multi-datacenter setups.", category: "databases" },
  { term: "Write-Ahead Log (WAL)", definition: "An append-only log where all changes are recorded before being applied to the database. Ensures durability and crash recovery.", category: "databases" },
  { term: "LSM Tree", definition: "Log-Structured Merge Tree. Write-optimized data structure that batches writes in memory (memtable), then flushes to sorted disk files (SSTables). Used by Cassandra, RocksDB, LevelDB.", category: "databases" },
  { term: "B-Tree", definition: "Self-balancing tree data structure used by most relational databases for indexing. O(log n) reads and writes. Optimized for disk-based storage with large node sizes.", category: "databases" },
  { term: "SSTable", definition: "Sorted String Table. An immutable, sorted key-value file on disk. Foundation of LSM trees. Enables efficient range queries and merging.", category: "databases" },
  { term: "Denormalization", definition: "Storing redundant data to avoid expensive JOINs. Trades write complexity and storage for faster reads. Common in read-heavy systems and NoSQL.", category: "databases" },
  { term: "Normalization", definition: "Organizing data to minimize redundancy. Data is split into related tables with foreign keys. Reduces anomalies but requires JOINs for queries.", category: "databases" },
  { term: "Index", definition: "A data structure that speeds up data retrieval at the cost of additional storage and slower writes. Types: B-tree, hash, bitmap, full-text, spatial.", category: "databases" },
  { term: "Materialized View", definition: "A precomputed query result stored as a table. Updated periodically or on trigger. Speeds up expensive aggregation queries at the cost of staleness.", category: "databases" },
  { term: "Connection Pool", definition: "A cache of database connections that are reused rather than created/destroyed per request. Reduces connection overhead. Tools: PgBouncer, HikariCP.", category: "databases" },
  { term: "Read Replica", definition: "A copy of the primary database that serves read queries. Offloads read traffic from the primary. May have slight replication lag.", category: "databases" },
  { term: "Hot Spot / Hot Partition", definition: "When one shard/partition receives disproportionate traffic due to skewed data distribution. Solution: salting keys, separate handling for hot keys.", category: "databases" },
  { term: "Tombstone", definition: "A marker indicating that a record has been deleted. Used in eventually consistent systems where deletes must propagate. Cleaned up during compaction.", category: "databases" },
  { term: "Compaction", definition: "The process of merging and cleaning up SSTable files in LSM trees. Removes tombstones, merges overlapping files, and reclaims space.", category: "databases" },
  { term: "Change Data Capture (CDC)", definition: "Capturing row-level changes in a database and streaming them as events. Enables real-time data integration, cache invalidation, and event-driven architectures.", category: "databases" },

  // === CACHING ===
  { term: "Cache", definition: "A high-speed storage layer that stores a subset of data for faster access. Reduces database load and latency. Types: in-memory (Redis, Memcached), CDN, browser.", category: "caching" },
  { term: "Cache-Aside (Lazy Loading)", definition: "Application checks cache first; on miss, reads from DB and populates cache. Most common pattern. Cache only contains requested data.", category: "caching" },
  { term: "Write-Through Cache", definition: "Every write goes to both cache and database. Cache is always consistent but writes are slower (double write). Good for read-heavy workloads.", category: "caching" },
  { term: "Write-Back (Write-Behind) Cache", definition: "Writes go to cache only, then asynchronously flushed to database. Very fast writes but risk of data loss if cache crashes before flush.", category: "caching" },
  { term: "Write-Around Cache", definition: "Writes go directly to database, bypassing cache. Cache is populated only on read misses. Avoids cache pollution from write-heavy workloads.", category: "caching" },
  { term: "Cache Eviction", definition: "Removing entries from cache when full. Policies: LRU (least recently used), LFU (least frequently used), FIFO, TTL-based, random.", category: "caching" },
  { term: "TTL (Time To Live)", definition: "Expiration time for cached data. After TTL, entry is considered stale and removed or refreshed. Balances freshness vs cache hit rate.", category: "caching" },
  { term: "Cache Stampede / Thundering Herd", definition: "When a popular cache entry expires and many concurrent requests all miss cache, overwhelming the database. Solutions: locking, lease, probabilistic early expiration.", category: "caching" },
  { term: "Cache Penetration", definition: "Requests for non-existent keys bypass cache and hit the database every time. Solution: cache null values with short TTL, or use Bloom filters.", category: "caching" },
  { term: "Cache Warming", definition: "Pre-populating cache with frequently accessed data before traffic arrives. Prevents cold-start cache misses.", category: "caching" },
  { term: "Redis", definition: "In-memory key-value store supporting rich data structures (strings, hashes, lists, sets, sorted sets). Single-threaded, ~100K QPS. Used for caching, sessions, rate limiting, pub/sub.", category: "caching" },
  { term: "Memcached", definition: "Simple, high-performance in-memory key-value cache. Multi-threaded, supports only string values. Used for caching at scale (Facebook uses it extensively).", category: "caching" },
  { term: "CDN (Content Delivery Network)", definition: "Geographically distributed network of edge servers that cache static content close to users. Reduces latency. Examples: CloudFront, Akamai, Cloudflare.", category: "caching" },

  // === NETWORKING ===
  { term: "DNS (Domain Name System)", definition: "Translates domain names to IP addresses. Hierarchical: root → TLD → authoritative nameservers. Cached at multiple levels. Can be used for load balancing.", category: "networking" },
  { term: "TCP", definition: "Transmission Control Protocol. Reliable, ordered, connection-oriented protocol. Three-way handshake. Guarantees delivery via retransmission. Used for HTTP, databases.", category: "networking" },
  { term: "UDP", definition: "User Datagram Protocol. Unreliable, connectionless, low-latency protocol. No guaranteed delivery or ordering. Used for video streaming, gaming, DNS queries.", category: "networking" },
  { term: "HTTP/HTTPS", definition: "Application-layer protocol for web communication. Request-response model. HTTPS adds TLS encryption. HTTP/2 adds multiplexing; HTTP/3 uses QUIC (UDP-based).", category: "networking" },
  { term: "WebSocket", definition: "Full-duplex communication protocol over a single TCP connection. Server can push data to clients. Used for real-time applications: chat, live feeds, gaming.", category: "networking" },
  { term: "Server-Sent Events (SSE)", definition: "One-way channel from server to client over HTTP. Simpler than WebSockets for server-push scenarios. Auto-reconnects. Used for live updates, notifications.", category: "networking" },
  { term: "gRPC", definition: "High-performance RPC framework using Protocol Buffers and HTTP/2. Supports streaming. More efficient than REST for service-to-service communication.", category: "networking" },
  { term: "REST", definition: "Representational State Transfer. Architectural style using HTTP methods (GET, POST, PUT, DELETE) on resources. Stateless. Most common API paradigm.", category: "networking" },
  { term: "GraphQL", definition: "Query language for APIs. Clients specify exactly what data they need. Solves over-fetching and under-fetching. Single endpoint. Invented by Facebook.", category: "networking" },
  { term: "TLS/SSL", definition: "Transport Layer Security. Encrypts data in transit. Provides authentication (certificates) and integrity. HTTPS = HTTP + TLS.", category: "networking" },
  { term: "Long Polling", definition: "Client sends request, server holds it open until data is available or timeout. Better than short polling but still overhead per connection. Bridge to WebSockets.", category: "networking" },
  { term: "Reverse Proxy", definition: "Server that sits in front of backend servers. Handles SSL termination, load balancing, caching, compression. Examples: Nginx, HAProxy.", category: "networking" },
  { term: "Forward Proxy", definition: "Server that sits in front of clients. Used for anonymity, caching, access control. Example: corporate proxy, VPN.", category: "networking" },

  // === SCALING ===
  { term: "Horizontal Scaling (Scale Out)", definition: "Adding more machines to distribute load. No single-machine ceiling. Requires distributed system design. Preferred for web-scale applications.", category: "scaling" },
  { term: "Vertical Scaling (Scale Up)", definition: "Adding more CPU, RAM, or storage to a single machine. Simpler but has hardware limits. Good for databases in early stages.", category: "scaling" },
  { term: "Load Balancer", definition: "Distributes incoming traffic across multiple servers. L4 (transport layer) or L7 (application layer). Algorithms: round-robin, least connections, IP hash, weighted.", category: "scaling" },
  { term: "Auto-Scaling", definition: "Automatically adjusting the number of server instances based on load metrics (CPU, QPS, queue depth). Handles traffic spikes without manual intervention.", category: "scaling" },
  { term: "Microservices", definition: "Architecture where application is composed of small, independent services each owning its data. Enables independent deployment and scaling. Tradeoff: operational complexity.", category: "scaling" },
  { term: "Monolith", definition: "Single deployable unit containing all application functionality. Simpler to develop and deploy initially. Becomes hard to scale and maintain as it grows.", category: "scaling" },
  { term: "Service Mesh", definition: "Infrastructure layer for service-to-service communication. Handles retries, circuit breaking, observability, mutual TLS. Examples: Istio, Linkerd.", category: "scaling" },
  { term: "Stateless Service", definition: "A service that doesn't store client state between requests. Any instance can handle any request. Easy to scale horizontally. State moved to external stores.", category: "scaling" },
  { term: "Database Partitioning", definition: "Dividing a database into pieces. Horizontal (by rows/sharding) or vertical (by columns). Enables parallel processing and larger datasets.", category: "scaling" },
  { term: "Rate Limiting", definition: "Controlling the rate of requests a client can make. Prevents abuse and protects resources. Algorithms: token bucket, leaky bucket, fixed/sliding window.", category: "scaling" },
  { term: "Throttling", definition: "Reducing the processing rate when system is under stress. Can drop requests, queue them, or return degraded responses. Protects system stability.", category: "scaling" },
  { term: "Backpressure", definition: "Flow control mechanism where overwhelmed downstream services signal upstream to slow down. Prevents cascading failures. Used in reactive systems and streaming.", category: "scaling" },

  // === ARCHITECTURE PATTERNS ===
  { term: "CQRS", definition: "Command Query Responsibility Segregation. Separate models for reads and writes. Enables independent optimization and scaling of each path.", category: "architecture" },
  { term: "Event Sourcing", definition: "Storing all changes as a sequence of immutable events rather than current state. Can rebuild state by replaying events. Full audit trail.", category: "architecture" },
  { term: "Event-Driven Architecture", definition: "System components communicate via events (messages). Loose coupling, async processing. Components: producers, event bus/broker, consumers.", category: "architecture" },
  { term: "Pub/Sub (Publish-Subscribe)", definition: "Messaging pattern where publishers send messages to topics, subscribers receive from topics. Decouples senders and receivers. Examples: Kafka, Redis Pub/Sub, SNS.", category: "architecture" },
  { term: "Message Queue", definition: "Async communication between services. Producer enqueues messages, consumer dequeues. Provides buffering, retry, and decoupling. Examples: Kafka, RabbitMQ, SQS.", category: "architecture" },
  { term: "API Gateway", definition: "Single entry point for all client requests to microservices. Handles routing, authentication, rate limiting, response aggregation. Examples: Kong, AWS API Gateway.", category: "architecture" },
  { term: "Circuit Breaker", definition: "Pattern that detects failures and prevents cascading by stopping requests to failing services. States: closed (normal), open (failing), half-open (testing recovery).", category: "architecture" },
  { term: "Bulkhead", definition: "Isolating components so failure in one doesn't affect others. Like a ship's compartments. Implementation: separate thread pools, connection pools, or instances per service.", category: "architecture" },
  { term: "Sidecar Pattern", definition: "Deploying helper functionality (logging, monitoring, TLS) as a separate process alongside the main application. Used in service meshes (Envoy proxy).", category: "architecture" },
  { term: "Strangler Fig Pattern", definition: "Gradually replacing a monolithic system by routing requests to new microservices one feature at a time. Old system 'strangled' as new system grows.", category: "architecture" },
  { term: "LAMP/MEAN/MERN Stack", definition: "Common technology stacks. LAMP: Linux/Apache/MySQL/PHP. MEAN: MongoDB/Express/Angular/Node. MERN: MongoDB/Express/React/Node.", category: "architecture" },
  { term: "Twelve-Factor App", definition: "Methodology for building SaaS apps: codebase, dependencies, config, backing services, build/release/run, processes, port binding, concurrency, disposability, dev/prod parity, logs, admin.", category: "architecture" },
  { term: "Domain-Driven Design (DDD)", definition: "Software design approach centered on the business domain. Key concepts: bounded contexts, aggregates, entities, value objects, domain events.", category: "architecture" },
  { term: "Consistent Hashing", definition: "Hashing technique where adding/removing nodes only redistributes ~1/N of keys. Nodes and keys map to a ring. Used for cache distribution and database sharding.", category: "architecture" },
  { term: "Bloom Filter", definition: "Space-efficient probabilistic data structure for set membership. No false negatives, possible false positives. Used to avoid unnecessary DB lookups.", category: "architecture" },
  { term: "MapReduce", definition: "Programming model for processing large datasets in parallel. Map phase transforms data, Reduce phase aggregates results. Foundation of Hadoop.", category: "architecture" },
  { term: "Lambda Architecture", definition: "Data processing architecture with batch layer (accurate, slow), speed layer (approximate, fast), and serving layer (merges both). Handles both real-time and historical queries.", category: "architecture" },
  { term: "Kappa Architecture", definition: "Simplified Lambda architecture that uses only a streaming layer. All data processed as a stream. Simpler but may be harder for complex batch analytics.", category: "architecture" },

  // === ADDITIONAL TERMS ===
  { term: "Snowflake ID", definition: "Twitter's distributed unique ID generator. 64-bit: timestamp (41 bits) + datacenter (5) + machine (5) + sequence (12). Time-sortable, ~4096 IDs/ms/machine.", category: "distributed-systems" },
  { term: "Geohash", definition: "Encoding system that converts 2D geographic coordinates into a 1D string. Nearby locations share prefixes. Used for proximity queries in location-based services.", category: "databases" },
  { term: "Quadtree", definition: "Tree data structure where each node has exactly 4 children, recursively subdividing 2D space. Used for spatial indexing in maps and location services.", category: "databases" },
  { term: "Trie (Prefix Tree)", definition: "Tree data structure for storing strings where each node represents a character. Enables fast prefix lookups. Used for autocomplete, spell checking, IP routing.", category: "databases" },
  { term: "Consistent Read", definition: "A read that returns the most recent write. Requires reading from the leader or using quorum reads. Higher latency than eventually consistent reads.", category: "databases" },
  { term: "Eventual Consistency", definition: "Guarantee that, given no new writes, all replicas will eventually converge to the same value. Window of inconsistency varies. Used by DynamoDB, Cassandra.", category: "distributed-systems" },
  { term: "Strong Consistency", definition: "Every read returns the most recent write. All nodes see the same data at the same time. Higher latency and lower availability during partitions.", category: "distributed-systems" },
  { term: "SLA (Service Level Agreement)", definition: "Contract defining expected service quality: availability (99.99%), latency (p99 < 200ms), throughput. Violation may trigger penalties.", category: "scaling" },
  { term: "SLO (Service Level Objective)", definition: "Internal target for service quality metrics. More stringent than SLA. Example: p99 latency < 100ms when SLA says < 200ms.", category: "scaling" },
  { term: "Observability", definition: "Ability to understand system state from external outputs. Three pillars: metrics (numeric measurements), logs (event records), traces (request flow across services).", category: "scaling" },
  { term: "Distributed Tracing", definition: "Tracking a request as it flows through multiple services. Each span records timing and metadata. Tools: Jaeger, Zipkin, OpenTelemetry.", category: "scaling" },
  { term: "Blue-Green Deployment", definition: "Running two identical environments (blue=current, green=new). Switch traffic to green after testing. Instant rollback by switching back to blue.", category: "architecture" },
  { term: "Canary Deployment", definition: "Rolling out a new version to a small subset of users/servers first. Monitor for issues before full rollout. Reduces blast radius of bugs.", category: "architecture" },
  { term: "Feature Flag", definition: "Conditional logic that enables/disables features without deploying new code. Used for canary releases, A/B testing, and quick rollback.", category: "architecture" },
  { term: "Data Lake", definition: "Centralized repository for storing raw data at any scale in its native format. Schema-on-read. Used for analytics and ML. Examples: S3, HDFS.", category: "databases" },
  { term: "Data Warehouse", definition: "Structured storage optimized for analytical queries. Schema-on-write. Star/snowflake schemas. Examples: Redshift, BigQuery, Snowflake.", category: "databases" },
  { term: "ETL (Extract, Transform, Load)", definition: "Process of extracting data from sources, transforming it to fit the target schema, and loading it into a data warehouse. Batch or streaming.", category: "databases" },
  { term: "Object Storage", definition: "Storage for unstructured data (files, images, videos) as objects with metadata. Highly scalable. Examples: S3, GCS, Azure Blob Storage.", category: "scaling" },
  { term: "Block Storage", definition: "Low-level storage that splits data into fixed-size blocks. Used for databases and VMs. Examples: EBS, Azure Disk.", category: "scaling" },
  { term: "Proxy", definition: "An intermediary server between clients and backend. Forward proxy acts on behalf of clients; reverse proxy acts on behalf of servers.", category: "networking" },
  { term: "Hinted Handoff", definition: "When a node is temporarily unavailable, another node stores writes intended for it. When the node recovers, the hints are replayed. Used in Dynamo-style systems.", category: "distributed-systems" },
  { term: "Anti-Entropy", definition: "Background process that compares and synchronizes data between replicas to ensure consistency. Uses Merkle trees for efficient comparison. Used by Cassandra, Dynamo.", category: "distributed-systems" },
  { term: "Merkle Tree", definition: "Hash tree where leaves are data blocks and each parent is the hash of its children. Enables efficient comparison of large datasets. Used for anti-entropy in distributed databases.", category: "distributed-systems" },
];
